#include "parse.h"

/* name has a live reference. 'is_let' is only used with opcode =
   OP_scope_get_var which is never generated by get_lvalue(). */
void put_lvalue(JSParseState *s, int opcode, int scope, JSAtom name, int label,
                PutLValueEnum special, BOOL is_let) {
  switch (opcode) {
  case OP_get_field:
  case OP_scope_get_private_field:
    /* depth = 1 */
    switch (special) {
    case PUT_LVALUE_NOKEEP:
    case PUT_LVALUE_NOKEEP_DEPTH:
      break;
    case PUT_LVALUE_KEEP_TOP:
      emit_op(s, OP_insert2); /* obj v -> v obj v */
      break;
    case PUT_LVALUE_KEEP_SECOND:
      emit_op(s, OP_perm3); /* obj v0 v -> v0 obj v */
      break;
    case PUT_LVALUE_NOKEEP_BOTTOM:
      emit_op(s, OP_swap);
      break;
    default:
      abort();
    }
    break;
  case OP_get_array_el:
  case OP_get_ref_value:
    /* depth = 2 */
    if (opcode == OP_get_ref_value) {
      JS_FreeAtom(s->ctx, name);
      emit_label(s, label);
    }
    switch (special) {
    case PUT_LVALUE_NOKEEP:
      emit_op(s, OP_nop); /* will trigger optimization */
      break;
    case PUT_LVALUE_NOKEEP_DEPTH:
      break;
    case PUT_LVALUE_KEEP_TOP:
      emit_op(s, OP_insert3); /* obj prop v -> v obj prop v */
      break;
    case PUT_LVALUE_KEEP_SECOND:
      emit_op(s, OP_perm4); /* obj prop v0 v -> v0 obj prop v */
      break;
    case PUT_LVALUE_NOKEEP_BOTTOM:
      emit_op(s, OP_rot3l);
      break;
    default:
      abort();
    }
    break;
  case OP_get_super_value:
    /* depth = 3 */
    switch (special) {
    case PUT_LVALUE_NOKEEP:
    case PUT_LVALUE_NOKEEP_DEPTH:
      break;
    case PUT_LVALUE_KEEP_TOP:
      emit_op(s, OP_insert4); /* this obj prop v -> v this obj prop v */
      break;
    case PUT_LVALUE_KEEP_SECOND:
      emit_op(s, OP_perm5); /* this obj prop v0 v -> v0 this obj prop v */
      break;
    case PUT_LVALUE_NOKEEP_BOTTOM:
      emit_op(s, OP_rot4l);
      break;
    default:
      abort();
    }
    break;
  default:
    break;
  }

  switch (opcode) {
  case OP_scope_get_var: /* val -- */
    assert(special == PUT_LVALUE_NOKEEP || special == PUT_LVALUE_NOKEEP_DEPTH);
    emit_op(s, is_let ? OP_scope_put_var_init : OP_scope_put_var);
    emit_u32(s, name); /* has refcount */
    emit_u16(s, scope);
    break;
  case OP_get_field:
    emit_op(s, OP_put_field);
    emit_u32(s, name); /* name has refcount */
    break;
  case OP_scope_get_private_field:
    emit_op(s, OP_scope_put_private_field);
    emit_u32(s, name); /* name has refcount */
    emit_u16(s, scope);
    break;
  case OP_get_array_el:
    emit_op(s, OP_put_array_el);
    break;
  case OP_get_ref_value:
    emit_op(s, OP_put_ref_value);
    break;
  case OP_get_super_value:
    emit_op(s, OP_put_super_value);
    break;
  default:
    abort();
  }
}

__exception int get_lvalue(JSParseState *s, int *popcode, int *pscope,
                           JSAtom *pname, int *plabel, int *pdepth, BOOL keep,
                           int tok) {
  JSFunctionDef *fd;
  int opcode, scope, label, depth;
  JSAtom name;

  /* we check the last opcode to get the lvalue type */
  fd = s->cur_func;
  scope = 0;
  name = JS_ATOM_NULL;
  label = -1;
  depth = 0;
  switch (opcode = get_prev_opcode(fd)) {
  case OP_scope_get_var:
    name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
    scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
    if ((name == JS_ATOM_arguments || name == JS_ATOM_eval) &&
        (fd->js_mode & JS_MODE_STRICT)) {
      return js_parse_error(s, "invalid lvalue in strict mode");
    }
    if (name == JS_ATOM_this || name == JS_ATOM_new_target)
      goto invalid_lvalue;
    depth = 2; /* will generate OP_get_ref_value */
    break;
  case OP_get_field:
    name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
    depth = 1;
    break;
  case OP_scope_get_private_field:
    name = get_u32(fd->byte_code.buf + fd->last_opcode_pos + 1);
    scope = get_u16(fd->byte_code.buf + fd->last_opcode_pos + 5);
    depth = 1;
    break;
  case OP_get_array_el:
    depth = 2;
    break;
  case OP_get_super_value:
    depth = 3;
    break;
  default:
  invalid_lvalue:
    if (tok == TOK_FOR) {
      return js_parse_error(s, "invalid for in/of left hand-side");
    } else if (tok == TOK_INC || tok == TOK_DEC) {
      return js_parse_error(s, "invalid increment/decrement operand");
    } else if (tok == '[' || tok == '{') {
      return js_parse_error(s, "invalid destructuring target");
    } else {
      return js_parse_error(s, "invalid assignment left-hand side");
    }
  }
  /* remove the last opcode */
  fd->byte_code.size = fd->last_opcode_pos;
  fd->last_opcode_pos = -1;

  if (keep) {
    /* get the value but keep the object/fields on the stack */
    switch (opcode) {
    case OP_scope_get_var:
      label = new_label(s);
      emit_op(s, OP_scope_make_ref);
      emit_atom(s, name);
      emit_u32(s, label);
      emit_u16(s, scope);
      update_label(fd, label, 1);
      emit_op(s, OP_get_ref_value);
      opcode = OP_get_ref_value;
      break;
    case OP_get_field:
      emit_op(s, OP_get_field2);
      emit_atom(s, name);
      break;
    case OP_scope_get_private_field:
      emit_op(s, OP_scope_get_private_field2);
      emit_atom(s, name);
      emit_u16(s, scope);
      break;
    case OP_get_array_el:
      /* XXX: replace by a single opcode ? */
      emit_op(s, OP_to_propkey2);
      emit_op(s, OP_dup2);
      emit_op(s, OP_get_array_el);
      break;
    case OP_get_super_value:
      emit_op(s, OP_to_propkey);
      emit_op(s, OP_dup3);
      emit_op(s, OP_get_super_value);
      break;
    default:
      abort();
    }
  } else {
    switch (opcode) {
    case OP_scope_get_var:
      label = new_label(s);
      emit_op(s, OP_scope_make_ref);
      emit_atom(s, name);
      emit_u32(s, label);
      emit_u16(s, scope);
      update_label(fd, label, 1);
      opcode = OP_get_ref_value;
      break;
    case OP_get_array_el:
      emit_op(s, OP_to_propkey2);
      break;
    case OP_get_super_value:
      emit_op(s, OP_to_propkey);
      break;
    }
  }

  *popcode = opcode;
  *pscope = scope;
  /* name has refcount for OP_get_field and OP_get_ref_value,
     and JS_ATOM_NULL for other opcodes */
  *pname = name;
  *plabel = label;
  if (pdepth)
    *pdepth = depth;
  return 0;
}